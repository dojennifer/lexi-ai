<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LexiAi - Underwriting Assistant</title>
    <style>
        :root {
            --background-color: #f8f9fe;
            --text-color: #202124;
            --card-background: #ffffff;
            --card-border: #dadce0;
            --primary-color: #4285f4;
            --secondary-color: #8e918f;
            --button-hover: #f1f3f4;
            --chat-background: #f8f9fe;
            --user-message-bg: #e5e7eb;
            --assistant-message-bg: #ffffff;
            --assistant-message-border: #dadce0;
            --chip-background: #f1f3f4;
            --chip-hover: #e8eaed;
            --input-background: #ffffff;
            --input-border: #dadce0;
            --blue-button: #4285f4;
            --blue-button-text: #ffffff;
            --shadow-color: rgba(60, 64, 67, 0.1);
        }

        [data-theme="dark"] {
            --background-color: #202124;
            --text-color: #e8eaed;
            --card-background: #303134;
            --card-border: #5f6368;
            --primary-color: #8ab4f8;
            --secondary-color: #9aa0a6;
            --button-hover: #3c4043;
            --chat-background: #202124;
            --user-message-bg: #3c4043;
            --assistant-message-bg: #303134;
            --assistant-message-border: #5f6368;
            --chip-background: #3c4043;
            --chip-hover: #4d5156;
            --input-background: #303134;
            --input-border: #5f6368;
            --blue-button: #8ab4f8;
            --blue-button-text: #202124;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }
        
        body {
            font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            position: relative;
        }
        
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            border-bottom: 1px solid var(--card-border);
        }
        
        .header-left {
            display: flex;
            align-items: center;
        }
        
        .logo {
            font-size: 20px;
            font-weight: 500;
            margin-right: 10px;
            color: var(--text-color);
            cursor: pointer;
        }
        
        .experiment-tag {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            background-color: var(--chip-background);
            color: var(--secondary-color);
            margin-left: 8px;
        }
        
        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: var(--secondary-color);
            border-radius: 50%;
        }
        
        .theme-toggle:hover {
            background-color: var(--button-hover);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 0 24px;
        }
        
        .greeting-section {
            padding: 32px 0;
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        .greeting-section h1 {
            font-size: 32px;
            margin-bottom: 16px;
            font-weight: normal;
        }
        
        .greeting-section p {
            font-size: 16px;
            color: var(--secondary-color);
            max-width: 600px;
            margin: 0 auto 32px;
            line-height: 1.5;
        }
        
        .suggestions-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            border-radius: 8px;
            background-color: var(--card-background);
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        
        .suggestions-title {
            font-size: 16px;
            color: var(--primary-color);
            margin-bottom: 16px;
        }
        
        .suggestions-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .suggestion-chip {
            padding: 12px 16px;
            background-color: var(--chip-background);
            border-radius: 24px;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
            border: none;
            text-align: left;
            transition: background-color 0.2s;
        }
        
        .suggestion-chip:hover {
            background-color: var(--chip-hover);
        }
        
        .chat-input-area {
            max-width: 800px;
            margin: 0 auto 24px;
            width: 100%;
            position: relative;
        }
        
        .chat-input-container {
            display: flex;
            position: relative;
            border: 1px solid var(--input-border);
            border-radius: 24px;
            background-color: var(--input-background);
            box-shadow: 0 1px 3px var(--shadow-color);
            padding: 6px 16px;
            align-items: center;
        }
        
        .chat-input {
            flex: 1;
            border: none;
            background: transparent;
            min-height: 24px;
            max-height: 200px;
            outline: none;
            padding: 8px 0;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            font-size: 16px;
            color: var(--text-color);
            resize: none;
        }
        
        .chat-input::placeholder {
            color: var(--secondary-color);
        }
        
        .submit-button {
            background: none;
            color: var(--primary-color);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        .attribution {
            text-align: center;
            padding: 16px;
            color: var(--secondary-color);
            font-size: 14px;
            border-top: 1px solid var(--card-border);
            margin-top: auto;
        }
        
        .disclaimer {
            text-align: center;
            padding: 8px 16px;
            color: var(--secondary-color);
            font-size: 12px;
        }
        
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 300px); /* Set a fixed height */
            min-height: 300px; /* Ensure minimum height */
        }
        
        .message {
            max-width: 80%;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 8px;
            line-height: 1.5;
        }
        
        .user-message {
            align-self: flex-end;
            background-color: var(--user-message-bg);
        }
        
        .assistant-message {
            align-self: flex-start;
            background-color: var(--assistant-message-bg);
            border: 1px solid var(--assistant-message-border);
            padding: 20px; /* Increase padding for better readability */
        }
        
        /* Loader animation */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 16px;
        }
        
        .typing-indicator span {
            height: 8px;
            width: 8px;
            float: left;
            margin: 0 1px;
            background-color: var(--secondary-color);
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: typing 1s infinite;
        }
        
        .typing-indicator span:nth-of-type(1) {
            animation-delay: 0s;
        }
        
        .typing-indicator span:nth-of-type(2) {
            animation-delay: 0.2s;
        }
        
        .typing-indicator span:nth-of-type(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        .hidden {
            display: none;
        }
        
        .pre-formatted {
            background-color: var(--chip-background);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 16px 0;
        }
        
        /* API Key input styling */
        .api-key-container {
            max-width: 800px;
            margin: 20px auto;
            padding: 16px;
            background-color: var(--card-background);
            border-radius: 8px;
            border: 1px solid var(--card-border);
            box-sizing: border-box;
        }
        
        .api-key-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .api-key-container input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            background-color: var(--input-background);
            color: var(--text-color);
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        }
        
        .api-key-container input:focus {
            border-color: var(--primary-color);
        }
        
        /* Quick action buttons at bottom */
        .quick-actions {
            display: flex;
            max-width: 800px;
            margin: 0 auto;
            gap: 10px;
            padding-bottom: 16px;
            overflow-x: auto;
        }
        
        .action-button {
            white-space: nowrap;
            background-color: var(--chip-background);
            border: none;
            border-radius: 20px;
            padding: 10px 16px;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
        }
        
        .action-button:hover {
            background-color: var(--chip-hover);
        }
        
        /* Progress bar style */
        .progress-bar {
            height: 4px;
            width: 100%;
            background-color: var(--card-border);
            position: fixed;
            bottom: 0;
        }
        
        .progress {
            height: 100%;
            width: 50%;
            background-color: var(--primary-color);
        }
        
        /* Update link styling for both light and dark modes */
        a {
            color: #4285f4; /* Blue color in light mode */
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        [data-theme="dark"] a {
            color: #8ab4f8; /* Lighter blue for dark mode */
        }
        
        /* Citation styles */
        .message-citations {
            margin-top: 15px;
            font-size: 14px;
            color: var(--secondary-color);
        }
        
        /* Markdown styling */
        .assistant-message h3 {
            font-size: 1.3em;
            margin: 16px 0 8px 0;
            font-weight: 600;
        }
        
        /* Style for verdict and reasoning sections */
        .assistant-message h3.verdict-heading {
            color: var(--primary-color);
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 6px;
        }
        
        .assistant-message h3.reasoning-heading {
            color: var(--primary-color);
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 6px;
        }
        
        .assistant-message strong {
            font-weight: 600;
        }
        
        .assistant-message ol, .assistant-message ul {
            margin: 8px 0;
            padding-left: 25px;
        }
        
        .assistant-message li {
            margin-bottom: 6px;
            line-height: 1.5;
        }
        
        .assistant-message p {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .assistant-message {
            line-height: 1.5;
            font-size: 16px;
        }
        
        .message-citations hr {
            border: none;
            border-top: 1px solid var(--card-border);
            margin: 10px 0;
        }
        
        .message-citations h4 {
            margin: 10px 0;
            font-size: 14px;
            font-weight: 500;
        }
        
        .citation-list {
            margin: 5px 0;
            padding-left: 25px;
        }
        
        .citation-list li {
            margin-bottom: 5px;
        }
        
        /* Style for reasoning points */
        .reasoning-point {
            margin: 10px 0;
            padding: 8px 0;
        }
        
        .reasoning-point-number {
            font-weight: 600;
            color: var(--primary-color);
            margin-right: 8px;
        }
        
        /* Confidence interval styling */
        .confidence-interval {
            font-style: italic;
            color: var(--secondary-color);
            margin-top: 4px;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <div class="logo" onclick="resetToHome()">LexiAi</div>
                <div class="experiment-tag">Experiment</div>
            </div>
            <button class="theme-toggle" id="themeToggle">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </button>
        </header>
        
        <div class="main-content">
            <div id="homeView">
                <div class="greeting-section">
                    <h1>Hi, I'm LexiAi</h1>
                    <p>Tell me what's on your mind about underwriting. I have limitations and won't always get it right, but will do my best to answer your questions!</p>
                </div>
                
                <div class="suggestions-container">
                    <div class="suggestions-title">Getting Started</div>
                    <div class="suggestions-grid">
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Tell me about yourself</button>
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Where do you get your information from?</button>
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Who made this?</button>
                    </div>
                </div>
            </div>
            
            <div id="chatView" class="hidden">
                <div class="chat-container" id="chatMessages">
                    <!-- Messages will be added here dynamically -->
                </div>
            </div>
        </div>
        
        <div class="chat-input-area">
            <div class="chat-input-container">
                <textarea 
                    id="userMessage" 
                    class="chat-input" 
                    placeholder="Enter a prompt here" 
                    rows="1" 
                    onkeypress="handleKeyPress(event)"
                ></textarea>
                <button class="submit-button" onclick="sendMessage()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="currentColor"></path>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress"></div>
        </div>
        
        <div class="attribution">
            <div>Developed by <a href="https://www.linkedin.com/in/do-jennifer/" target="_blank">Jennifer Do</a></div>
        </div>
        
        <div class="disclaimer">
            LexiAi may display inaccurate or offensive information that doesn't represent our views.
        </div>
    </div>
    
    <script>
        // Helper function to escape special characters for regex
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
        }
        
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        // Set initial icon for dark mode
        themeToggle.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
        `;
        
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Update icon if needed
            if (newTheme === 'dark') {
                themeToggle.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                `;
            } else {
                themeToggle.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                `;
            }
        });
        
        // Handle submission of suggestion chips
        function submitSuggestion(text) {
            document.getElementById('userMessage').value = text;
            sendMessage();
        }
        
        // Function to check if user is asking who made the application
        function isAskingWhoMade(userInput) {
            const normalizedInput = userInput.toLowerCase().trim().replace(/[?!.,]/g, '');
            const whoMadePatterns = [
                'who made this',
                'who created this',
                'who developed this',
                'who built this',
                'who is the creator',
                'who is the developer',
                'about the creator',
                'about the developer'
            ];
            
            return whoMadePatterns.some(pattern => normalizedInput.includes(pattern));
        }
        
        // Hardcoded response about LexiAI
        const whoMadeResponse = `LexiAI, developed by <a href="https://www.linkedin.com/in/do-jennifer/" target="_blank">Jennifer Do</a>, is an AI-powered chatbot designed to assist with underwriting regulations in Ontario's auto insurance industry. Acting as an expert representative of the Financial Services Regulatory Authority of Ontario (FSRA), LexiAI answers complex underwriting queries from insurers, consumers, and FSRA employees, ensuring decisions align with regulatory standards.
        
        LexiAI was built to address two primary use cases:
        
        Underwriting Decline Rules – When an insurer wants to know if they can legally deny coverage based on a specific condition, LexiAI scans FSRA's regulatory documents and provides a compliance verdict, backed by citations.
        New Rule Submissions – Insurers propose new underwriting rules. LexiAI assesses whether the rule meets legal, ethical, and industry standards, considering fairness, objectivity, and precedent before delivering a decision.
        To power LexiAI, we developed a custom web scraper that collects legal and regulatory texts from Ontario's official databases. Using BeautifulSoup and Requests, this data is structured and fed into an LLM-powered framework, enabling LexiAI to process underwriting rules with accuracy and transparency.
        
        For each query, LexiAI provides:
        
        A compliance verdict (confidence score from 0-10)
        Justification based on FSRA guidelines
        Cited references to regulatory documents
        By automating compliance analysis, LexiAI streamlines regulatory decision-making for insurers and regulators alike.`;
        
        // Replace the current scrollChatToBottom function with this enhanced version
        function scrollChatToBottom() {
            const chatMessages = document.getElementById("chatMessages");
            
            // First immediate scroll to try to get to the bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Then use requestAnimationFrame for after the next paint
            requestAnimationFrame(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Add a backup delayed scroll to handle any late rendering
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 100);
            });
        }
        
        // Add this helper function at the top of your script section
        function handleApiError(error) {
            console.error("API Error:", error);
            
            // Check for specific error types
            if (error.message && error.message.includes("405")) {
                return "The server is currently unavailable. This could be due to maintenance or configuration issues. Please try again later.";
            } else if (error.message && error.message.includes("Network Error")) {
                return "Unable to connect to the server. Please check your internet connection and try again.";
            } else if (error.message && error.message.includes("timeout")) {
                return "The request timed out. The server might be experiencing high load. Please try again later.";
            } else {
                return `An error occurred: ${error.message}. Please try again later or contact support if the issue persists.`;
            }
        }
        
        // Add these helper functions at the top of your script section
        function getLocalResponse(userInput) {
            // Simple keyword-based response system
            userInput = userInput.toLowerCase();
            
            if (userInput.includes('hello') || userInput.includes('hi')) {
                return "Hello! I'm LexiAI, your assistant for underwriting regulations. How can I help you today?";
            }
            
            if (userInput.includes('tell me about yourself') || userInput.includes('what can you do')) {
                return "I'm LexiAI, an AI-powered assistant focused on Ontario's auto insurance regulations. I can help answer questions about underwriting rules, regulatory compliance, and FSRA guidelines. While my responses are informative, they should not be considered legal advice.";
            }
            
            if (userInput.includes('information') || userInput.includes('where do you get')) {
                return "My knowledge is based on Ontario's auto insurance regulations, including the Insurance Act, FSRA guidelines, and associated regulatory documents. This information has been processed to help me provide relevant responses about underwriting rules and compliance requirements.";
            }
            
            // Default response
            return "I understand you're asking about underwriting regulations. Due to temporary connectivity issues, I can only provide limited responses. Please try again later when the system is fully operational, or ask a different question I might be able to help with.";
        }
        
        async function fetchCitationMappings() {
            try {
                const response = await fetch("/public/citation_mappings.json");
                if (!response.ok) {
                    console.error("Failed to load citation mappings:", response.status);
                    return {};
                }
                const data = await response.json();
                
                // Convert the array to an object keyed by filename for easy lookup
                const mappings = {};
                data.mappings.forEach(item => {
                    mappings[item.filename] = {
                        display_name: item.display_name,
                        source_url: item.source_url
                    };
                });
                
                return mappings;
            } catch (error) {
                console.error("Error loading citation mappings:", error);
                return {};
            }
        }
        
        async function sendMessage() {
            const userMessage = document.getElementById("userMessage").value;
            const chatMessages = document.getElementById("chatMessages");
            
            if (!userMessage) {
                alert("Please enter a message.");
                return;
            }
            
            // Show chat view, hide home view
            document.getElementById('homeView').classList.add('hidden');
            document.getElementById('chatView').classList.remove('hidden');
            
            // Add user message to chat
            const userDiv = document.createElement("div");
            userDiv.className = "message user-message";
            userDiv.textContent = userMessage;
            chatMessages.appendChild(userDiv);
            
            // Clear input field and scroll to bottom
            document.getElementById("userMessage").value = "";
            scrollChatToBottom();
            
            // Create typing indicator
            const loadingDiv = document.createElement("div");
            loadingDiv.className = "message assistant-message typing-indicator";
            loadingDiv.innerHTML = "<span></span><span></span><span></span>";
            chatMessages.appendChild(loadingDiv);
            scrollChatToBottom();

            try {
                // Check for "Who made this?" first
                if (isAskingWhoMade(userMessage)) {
                    // Simulate a delayed response with the loading animation
                    setTimeout(() => {
                        // Remove loading indicator
                        chatMessages.removeChild(loadingDiv);
                        
                        // Display hardcoded response
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        assistantDiv.innerHTML = whoMadeResponse;
                        chatMessages.appendChild(assistantDiv);
                        scrollChatToBottom();
                    }, 2000); // Reduced to 2 second delay
                    
                    // Return early to prevent API calls
                    return;
                }
                
                // Wrap API calls in a try-catch to handle any errors
                try {
                    // Step 1: Create a Thread
                    const threadResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ action: "createThread" })
                    });
                    
                    // Check if response is ok before parsing JSON
                    if (!threadResponse.ok) {
                        throw new Error(`Server error: ${threadResponse.status} ${threadResponse.statusText}`);
                    }
                    
                    let threadData;
                    try {
                        threadData = await threadResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse thread response: " + e.message);
                    }
                    
                    if (!threadData.threadId) throw new Error("Error creating thread: Missing threadId");
                    const threadId = threadData.threadId;
                    
                    // Step 2: Add Message to Thread
                    const messageResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "addMessage", 
                            threadId: threadId, 
                            userMessage: userMessage 
                        })
                    });
                    
                    if (!messageResponse.ok) {
                        throw new Error(`Server error: ${messageResponse.status} ${messageResponse.statusText}`);
                    }
                    
                    let messageData;
                    try {
                        messageData = await messageResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse message response: " + e.message);
                    }
                    
                    if (messageData.error) throw new Error(messageData.error);
                    
                    // Step 3: Run the Assistant
                    const runResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "runAssistant", 
                            threadId: threadId
                        })
                    });
                    
                    if (!runResponse.ok) {
                        throw new Error(`Server error: ${runResponse.status} ${runResponse.statusText}`);
                    }
                    
                    let runData;
                    try {
                        runData = await runResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse run response: " + e.message);
                    }
                    
                    if (!runData.runId) throw new Error("Error running assistant: Missing runId");
                    const runId = runData.runId;
                    
                    // Step 4: Poll for Completion
                    let status = "in_progress";
                    let checkRunData;
                    
                    while (status === "in_progress" || status === "queued") {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        const checkRunResponse = await fetch("/.netlify/functions/openai-proxy", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ 
                                action: "checkRun", 
                                threadId: threadId,
                                runId: runId
                            })
                        });
                        
                        if (!checkRunResponse.ok) {
                            throw new Error(`Server error: ${checkRunResponse.status} ${checkRunResponse.statusText}`);
                        }
                        
                        try {
                            checkRunData = await checkRunResponse.json();
                            status = checkRunData.status;
                        } catch (e) {
                            throw new Error("Failed to parse check run response: " + e.message);
                        }
                    }
                    
                    // Step 5: Retrieve Response
                    const messagesResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "getMessages", 
                            threadId: threadId
                        })
                    });
                    
                    if (!messagesResponse.ok) {
                        throw new Error(`Server error: ${messagesResponse.status} ${messagesResponse.statusText}`);
                    }
                    
                    let messagesData;
                    try {
                        messagesData = await messagesResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse messages response: " + e.message);
                    }
                    
                    // Remove loading indicator
                    if (loadingDiv.parentNode) {
                        chatMessages.removeChild(loadingDiv);
                    }
                    
                    // Process and display assistant response
                    const assistantMessage = messagesData.messages && messagesData.messages.find(msg => msg.role === "assistant");
                    if (assistantMessage && assistantMessage.content) {
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        
                        // Process the message content based on its type
                        let formattedContent = "";
                        let citations = [];
                        
                        // Process all content items from the message
                        for (const content of assistantMessage.content) {
                            if (content.type === "text") {
                                // Get the text content and annotations
                                let text = content.text.value;
                                const annotations = content.text.annotations || [];
                                
                                // Process annotations (citations) if present
                                if (annotations && annotations.length > 0) {
                                    let citationIndex = 0;
                                    
                                    // Create an array to track positions where text needs to be replaced
                                    // This avoids issues with multiple replacements changing string offsets
                                    const replacements = [];
                                    
                                    // Process each annotation
                                    for (const annotation of annotations) {
                                        // Get the citation text and its position
                                        const citationText = annotation.text;
                                        
                                        // If it's a file citation
                                        if (annotation.file_citation) {
                                            const fileId = annotation.file_citation.file_id;
                                            // Use 1-based indexing for display
                                            const displayIndex = citationIndex + 1;
                                            const citationMarker = `[${displayIndex}]`;
                                            
                                            // Add to replacements array
                                            replacements.push({
                                                text: citationText,
                                                replacement: citationMarker
                                            });
                                            
                                            // Add to citations array
                                            citations.push({
                                                index: citationIndex,
                                                displayIndex: displayIndex,
                                                fileId: fileId
                                            });
                                            
                                            citationIndex++;
                                        }
                                    }
                                    
                                    // Apply all replacements
                                    // Replace all instances of citation text with the citation markers
                                    replacements.forEach(({ text: citationText, replacement }) => {
                                        // Use a regex to globally replace all instances of the citation text
                                        const regex = new RegExp(escapeRegExp(citationText), 'g');
                                        text = text.replace(regex, replacement);
                                    });
                                }
                                
                                // Format code blocks
                                text = text.replace(/```(\w*)([\s\S]*?)```/g, function(match, language, code) {
                                    return `<div class="pre-formatted">${code.trim()}</div>`;
                                });
                                
                                // Format markdown headings (### Heading) with special classes for verdict and reasoning
                                text = text.replace(/^###\s+(.*?)$/gm, function(match, heading) {
                                    if (heading.toLowerCase().includes('verdict')) {
                                        return `<h3 class="verdict-heading">${heading}</h3>`;
                                    } else if (heading.toLowerCase().includes('reasoning')) {
                                        return `<h3 class="reasoning-heading">${heading}</h3>`;
                                    } else {
                                        return `<h3>${heading}</h3>`;
                                    }
                                });
                                
                                // Format numbered reasons with special styling (e.g., "1. **Subjectivity and Arbitrary Nature**:")
                                text = text.replace(/(\d+)\.\s+\*\*(.*?)\*\*\s*:\s*(.*?)(?=(\n\d+\.\s+\*\*|\n### |\n$|$))/gs, 
                                    function(match, number, title, content) {
                                        return `<div class="reasoning-point">
                                            <span class="reasoning-point-number">${number}.</span>
                                            <strong>${title}</strong>: ${content.trim()}
                                        </div>`;
                                    });
                                
                                // Format confidence interval patterns like "**Confidence Interval: 9/10**"
                                text = text.replace(/\*\*Confidence Interval:?\s*([\d\.\/]+)\*\*/gi, 
                                    '<div class="confidence-interval">Confidence Interval: $1</div>');
                                
                                // Format verdict patterns
                                text = text.replace(/\*\*Not Compliant\*\*/gi, 
                                    '<strong style="color: var(--primary-color);">Not Compliant</strong>');
                                
                                // Format bold text (**text**)
                                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                                
                                // Handle consecutive numbered list items more effectively
                                let inNumberedList = false;
                                const lines = text.split('\n');
                                const processedLines = [];
                                
                                for (let i = 0; i < lines.length; i++) {
                                    const line = lines[i];
                                    const numberedListMatch = line.match(/^(\d+)\.\s+(.*?)$/);
                                    
                                    if (numberedListMatch) {
                                        if (!inNumberedList) {
                                            // Start a new list
                                            inNumberedList = true;
                                            processedLines.push(`<ol start="${numberedListMatch[1]}">`);
                                        }
                                        // Add list item
                                        processedLines.push(`<li>${numberedListMatch[2]}</li>`);
                                    } else {
                                        if (inNumberedList) {
                                            // Close the list
                                            inNumberedList = false;
                                            processedLines.push('</ol>');
                                        }
                                        processedLines.push(line);
                                    }
                                }
                                
                                // Close any open list
                                if (inNumberedList) {
                                    processedLines.push('</ol>');
                                }
                                
                                text = processedLines.join('\n');
                                
                                // Handle bullet lists in a similar way
                                inNumberedList = false;
                                const bulletLines = text.split('\n');
                                const processedBulletLines = [];
                                
                                for (let i = 0; i < bulletLines.length; i++) {
                                    const line = bulletLines[i];
                                    const bulletListMatch = line.match(/^\*\s+(.*?)$/);
                                    
                                    if (bulletListMatch) {
                                        if (!inNumberedList) {
                                            // Start a new list
                                            inNumberedList = true;
                                            processedBulletLines.push('<ul>');
                                        }
                                        // Add list item
                                        processedBulletLines.push(`<li>${bulletListMatch[1]}</li>`);
                                    } else {
                                        if (inNumberedList) {
                                            // Close the list
                                            inNumberedList = false;
                                            processedBulletLines.push('</ul>');
                                        }
                                        processedBulletLines.push(line);
                                    }
                                }
                                
                                // Close any open list
                                if (inNumberedList) {
                                    processedBulletLines.push('</ul>');
                                }
                                
                                text = processedBulletLines.join('\n');
                                
                                // Convert line breaks (but not inside HTML elements)
                                text = text.replace(/(?<!\>)\n(?!\<)/g, "<br>");
                                
                                formattedContent += text;
                            }
                        }
                        
                        // Add the formatted content to the message
                        assistantDiv.innerHTML = formattedContent;
                        
                        // If we have citations, fetch and display them
                        if (citations.length > 0) {
                            const citationsDiv = document.createElement("div");
                            citationsDiv.className = "message-citations";
                            citationsDiv.innerHTML = "<hr><h4>Sources:</h4><ol class='citation-list'></ol>";
                            const citationsList = citationsDiv.querySelector('.citation-list');
                            
                            // Process each citation asynchronously
                            const processCitations = async () => {
                                // First fetch the citation mappings
                                const citationMappings = await fetchCitationMappings();
                                
                                // Create an array to hold all citation items until we're ready to add them
                                const citationItems = new Array(citations.length);
                                
                                // Process all citations
                                const processPromises = citations.map(async (citation) => {
                                    try {
                                        // Fetch file information
                                        const fileResponse = await fetch("/.netlify/functions/openai-proxy", {
                                            method: "POST",
                                            headers: { "Content-Type": "application/json" },
                                            body: JSON.stringify({ 
                                                action: "retrieveFile", 
                                                fileId: citation.fileId
                                            })
                                        });
                                        
                                        const fileData = await fileResponse.json();
                                        const filename = fileData.file.filename;
                                        
                                        // Create citation item
                                        const citationItem = document.createElement("li");
                                        citationItem.value = citation.displayIndex || (citation.index + 1); // Ensure 1-based numbering
                                        
                                        // Normalize the filename for more robust matching
                                        // 1. Get basename without extension (if any)
                                        const basename = filename.split('.')[0] || filename;
                                        
                                        // 2. Try multiple matching strategies
                                        let found = false;
                                        let mapping = null;
                                        
                                        // First try exact match
                                        if (citationMappings[filename]) {
                                            mapping = citationMappings[filename];
                                            found = true;
                                        } 
                                        // Then try basename match
                                        else if (citationMappings[basename]) {
                                            mapping = citationMappings[basename];
                                            found = true;
                                        } 
                                        // If still not found, try finding by partial match
                                        else {
                                            for (const key in citationMappings) {
                                                // Check if key starts with or contains the basename
                                                if (key.includes(basename) || basename.includes(key)) {
                                                    mapping = citationMappings[key];
                                                    found = true;
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        // Display citation with proper formatting
                                        if (found && mapping) {
                                            citationItem.innerHTML = `<a href="${mapping.source_url}" target="_blank">${mapping.display_name}</a>`;
                                        } else {
                                            // If no mapping is found, just show the filename
                                            console.warn(`No mapping found for filename: ${filename}`);
                                            citationItem.textContent = filename;
                                        }
                                        
                                        // Store the item in the correct position in our array
                                        citationItems[citation.index] = citationItem;
                                    } catch (error) {
                                        console.error("Error fetching citation:", error);
                                        const citationItem = document.createElement("li");
                                        // Use 1-based indexing for the display
                                        citationItem.value = citation.displayIndex || (citation.index + 1);
                                        citationItem.textContent = `Citation ${citation.displayIndex || (citation.index + 1)} (Unable to retrieve details)`;
                                        
                                        // Store the error item in the correct position
                                        citationItems[citation.index] = citationItem;
                                    }
                                });
                                
                                // Wait for all citations to be processed
                                await Promise.all(processPromises);
                                
                                // Now add all citation items to the list in the correct order
                                citationItems.forEach(item => {
                                    if (item) {
                                        citationsList.appendChild(item);
                                    }
                                });
                            };
                            
                            // Start processing citations
                            processCitations();
                            
                            // Add citations div to the message
                            assistantDiv.appendChild(citationsDiv);
                        }
                        
                        chatMessages.appendChild(assistantDiv);
                    } else {
                        const errorDiv = document.createElement("div");
                        errorDiv.className = "message assistant-message";
                        errorDiv.textContent = "No response from assistant. The API may be temporarily unavailable.";
                        chatMessages.appendChild(errorDiv);
                    }
                } catch (apiError) {
                    console.error("API Error:", apiError);
                    
                    // Server is unavailable, use the fallback system
                    setTimeout(() => {
                        // Remove loading indicator
                        chatMessages.removeChild(loadingDiv);
                        
                        // Show fallback response
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        assistantDiv.innerHTML = getLocalResponse(userMessage);
                        chatMessages.appendChild(assistantDiv);
                        
                        // Add a note about offline mode
                        const noteDiv = document.createElement("div");
                        noteDiv.className = "message assistant-message";
                        noteDiv.innerHTML = "<em>Note: LexiAI is currently in offline mode due to server connectivity issues.</em>";
                        noteDiv.style.fontSize = "0.8em";
                        noteDiv.style.opacity = "0.7";
                        chatMessages.appendChild(noteDiv);
                        
                        scrollChatToBottom();
                    }, 1500);
                    
                    return;
                }
            } catch (error) {
                console.error("Error:", error);
                
                // Remove loading indicator if it exists
                if (loadingDiv.parentNode) {
                    chatMessages.removeChild(loadingDiv);
                }
                
                // Get user-friendly error message
                const errorMessage = handleApiError(error);
                
                // Show error message
                const errorDiv = document.createElement("div");
                errorDiv.className = "message assistant-message";
                errorDiv.textContent = errorMessage;
                chatMessages.appendChild(errorDiv);
                
                scrollChatToBottom();
            }
            
            // Scroll to bottom
            scrollChatToBottom();
        }
        
        // Allow pressing Enter key to send message
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // Auto-resize textarea
        const textarea = document.getElementById('userMessage');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
        
        // Function to reset to home page
        function resetToHome() {
            // Show home view, hide chat view
            document.getElementById('homeView').classList.remove('hidden');
            document.getElementById('chatView').classList.add('hidden');
            
            // Clear the chat messages
            document.getElementById('chatMessages').innerHTML = '';
            
            // Clear the input field if there's any text
            document.getElementById('userMessage').value = '';
        }
    </script>
</body>
</html> 