<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LexiAi - Underwriting Assistant</title>
    <style>
        :root {
            --background-color: #f8f9fe;
            --text-color: #202124;
            --card-background: #ffffff;
            --card-border: #dadce0;
            --primary-color: #4285f4;
            --secondary-color: #8e918f;
            --button-hover: #f1f3f4;
            --chat-background: #f8f9fe;
            --user-message-bg: #e5e7eb;
            --assistant-message-bg: #ffffff;
            --assistant-message-border: #dadce0;
            --chip-background: #f1f3f4;
            --chip-hover: #e8eaed;
            --input-background: #ffffff;
            --input-border: #dadce0;
            --blue-button: #4285f4;
            --blue-button-text: #ffffff;
            --shadow-color: rgba(60, 64, 67, 0.1);
            --logo-bg: #F0F0FD;
            --logo-primary: #9AAFFE;
            --logo-secondary: #C2D2FE;
            --logo-accent: #6F7FFE;
            --logo-eyes: #5D5FEF;
        }

        [data-theme="dark"] {
            --background-color: #202124;
            --text-color: #e8eaed;
            --card-background: #303134;
            --card-border: #5f6368;
            --primary-color: #8ab4f8;
            --secondary-color: #9aa0a6;
            --button-hover: #3c4043;
            --chat-background: #202124;
            --user-message-bg: #3c4043;
            --assistant-message-bg: #303134;
            --assistant-message-border: #5f6368;
            --chip-background: #3c4043;
            --chip-hover: #4d5156;
            --input-background: #303134;
            --input-border: #5f6368;
            --blue-button: #8ab4f8;
            --blue-button-text: #202124;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --logo-bg: #3D3E65;
            --logo-primary: #99AEFD;
            --logo-secondary: #5C6C98;
            --logo-accent: #6E7DFC;
            --logo-eyes: #FDFDFD;
        }
        
        body {
            font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            position: relative;
        }
        
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            border-bottom: 1px solid var(--card-border);
        }
        
        .header-left {
            display: flex;
            align-items: center;
        }
        
        .logo {
            font-size: 20px;
            font-weight: 500;
            margin-right: 10px;
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo svg {
            width: 32px;
            height: 32px;
        }
        
        .logo-bg {
            fill: var(--logo-bg);
            transition: fill 0.3s ease;
        }
        
        .logo-primary {
            fill: var(--logo-primary);
            transition: fill 0.3s ease;
        }
        
        .logo-secondary {
            fill: var(--logo-secondary);
            transition: fill 0.3s ease;
        }
        
        .logo-accent {
            fill: var(--logo-accent);
            transition: fill 0.3s ease;
        }
        
        .logo-eyes {
            fill: var(--logo-eyes);
            transition: fill 0.3s ease;
        }
        
        .experiment-tag {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            background-color: var(--chip-background);
            color: var(--secondary-color);
            margin-left: 8px;
        }
        
        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: var(--secondary-color);
            border-radius: 50%;
        }
        
        .theme-toggle:hover {
            background-color: var(--button-hover);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 0 24px;
        }
        
        .greeting-section {
            padding: 32px 0;
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        .greeting-section h1 {
            font-size: 32px;
            margin-bottom: 16px;
            font-weight: normal;
        }
        
        .greeting-section p {
            font-size: 16px;
            color: var(--secondary-color);
            max-width: 600px;
            margin: 0 auto 32px;
            line-height: 1.5;
        }
        
        .suggestions-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            border-radius: 8px;
            background-color: var(--card-background);
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        
        .suggestions-title {
            font-size: 16px;
            color: var(--primary-color);
            margin-bottom: 16px;
        }
        
        .suggestions-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .suggestion-chip {
            padding: 12px 16px;
            background-color: var(--chip-background);
            border-radius: 24px;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
            border: none;
            text-align: left;
            transition: background-color 0.2s;
        }
        
        .suggestion-chip:hover {
            background-color: var(--chip-hover);
        }
        
        .chat-input-area {
            max-width: 800px;
            margin: 0 auto 24px;
            width: 100%;
            position: relative;
        }
        
        .chat-input-container {
            display: flex;
            position: relative;
            border: 1px solid var(--input-border);
            border-radius: 24px;
            background-color: var(--input-background);
            box-shadow: 0 1px 3px var(--shadow-color);
            padding: 6px 16px;
            align-items: center;
        }
        
        .chat-input {
            flex: 1;
            border: none;
            background: transparent;
            min-height: 24px;
            max-height: 200px;
            outline: none;
            padding: 8px 0;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            font-size: 16px;
            color: var(--text-color);
            resize: none;
        }
        
        .chat-input::placeholder {
            color: var(--secondary-color);
        }
        
        .submit-button {
            background: none;
            color: var(--primary-color);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        .attribution {
            text-align: center;
            padding: 16px;
            color: var(--secondary-color);
            font-size: 14px;
            border-top: 1px solid var(--card-border);
            margin-top: auto;
        }
        
        .disclaimer {
            text-align: center;
            padding: 8px 16px;
            color: var(--secondary-color);
            font-size: 12px;
        }
        
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 300px); /* Set a fixed height */
            min-height: 300px; /* Ensure minimum height */
        }
        
        .message {
            max-width: 80%;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 8px;
            line-height: 1.5;
        }
        
        .user-message {
            align-self: flex-end;
            background-color: var(--user-message-bg);
        }
        
        .assistant-message {
            align-self: flex-start;
            background-color: var(--assistant-message-bg);
            border: 1px solid var(--assistant-message-border);
            padding: 20px; /* Increase padding for better readability */
        }
        
        /* Loader animation */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 16px;
        }
        
        .typing-indicator span {
            height: 8px;
            width: 8px;
            float: left;
            margin: 0 1px;
            background-color: var(--secondary-color);
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: typing 1s infinite;
        }
        
        .typing-indicator span:nth-of-type(1) {
            animation-delay: 0s;
        }
        
        .typing-indicator span:nth-of-type(2) {
            animation-delay: 0.2s;
        }
        
        .typing-indicator span:nth-of-type(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        .hidden {
            display: none;
        }
        
        .pre-formatted {
            background-color: var(--chip-background);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 16px 0;
        }
        
        /* API Key input styling */
        .api-key-container {
            max-width: 800px;
            margin: 20px auto;
            padding: 16px;
            background-color: var(--card-background);
            border-radius: 8px;
            border: 1px solid var(--card-border);
            box-sizing: border-box;
        }
        
        .api-key-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .api-key-container input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            background-color: var(--input-background);
            color: var(--text-color);
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        }
        
        .api-key-container input:focus {
            border-color: var(--primary-color);
        }
        
        /* Quick action buttons at bottom */
        .quick-actions {
            display: flex;
            max-width: 800px;
            margin: 0 auto;
            gap: 10px;
            padding-bottom: 16px;
            overflow-x: auto;
        }
        
        .action-button {
            white-space: nowrap;
            background-color: var(--chip-background);
            border: none;
            border-radius: 20px;
            padding: 10px 16px;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
        }
        
        .action-button:hover {
            background-color: var(--chip-hover);
        }
        
        /* Progress bar style */
        .progress-bar {
            height: 4px;
            width: 100%;
            background-color: var(--card-border);
            position: fixed;
            bottom: 0;
        }
        
        .progress {
            height: 100%;
            width: 50%;
            background-color: var(--primary-color);
        }
        
        /* Update link styling for both light and dark modes */
        a {
            color: #4285f4; /* Blue color in light mode */
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        [data-theme="dark"] a {
            color: #8ab4f8; /* Lighter blue for dark mode */
        }
        
        /* Citation styles */
        .message-citations {
            margin-top: 15px;
            font-size: 14px;
            color: var(--secondary-color);
        }
        
        /* Markdown styling */
        .assistant-message h3 {
            font-size: 1.3em;
            margin: 16px 0 8px 0;
            font-weight: 600;
        }
        
        /* Style for verdict and reasoning sections */
        .assistant-message h3.verdict-heading {
            color: var(--primary-color);
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 6px;
        }
        
        .assistant-message h3.reasoning-heading {
            color: var(--primary-color);
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 6px;
        }
        
        .assistant-message strong {
            font-weight: 600;
        }
        
        .assistant-message ol, .assistant-message ul {
            margin: 8px 0;
            padding-left: 25px;
        }
        
        .assistant-message li {
            margin-bottom: 6px;
            line-height: 1.5;
        }
        
        .assistant-message p {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .assistant-message {
            line-height: 1.5;
            font-size: 16px;
        }
        
        .message-citations hr {
            border: none;
            border-top: 1px solid var(--card-border);
            margin: 10px 0;
        }
        
        .message-citations h4 {
            margin: 10px 0;
            font-size: 14px;
            font-weight: 500;
        }
        
        .citation-list {
            margin: 5px 0;
            padding-left: 25px;
        }
        
        .citation-list li {
            margin-bottom: 5px;
        }
        
        /* Style for reasoning points */
        .reasoning-point {
            margin: 10px 0;
            padding: 8px 0;
        }
        
        .reasoning-point-number {
            font-weight: 600;
            color: var(--primary-color);
            margin-right: 8px;
        }
        
        /* Confidence interval styling */
        .confidence-interval {
            font-style: italic;
            color: var(--secondary-color);
            margin-top: 4px;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <div class="logo" onclick="resetToHome()">
                    <svg viewBox="0 0 1080 1080" xmlns="http://www.w3.org/2000/svg">
                        <g clip-path="url(#logo-clip)">
                            <!-- Background -->
                            <path class="logo-bg" d="M0 0 C356.4 0 712.8 0 1080 0 C1080 356.4 1080 712.8 1080 1080 C723.6 1080 367.2 1080 0 1080 C0 723.6 0 367.2 0 0 Z" />
                            
                            <!-- Main outer circle -->
                            <path class="logo-secondary" d="M0 0 C1.09452484 -0.00095673 2.18904968 -0.00191345 3.31674194 -0.00289917 C122.02436405 11.15596774 167.42256681 26.28217822 205.0859375 55.1328125 C260.51764858 110.84964141 268.63348238 124.19459607 276.0859375 138.1328125 C309.90090456 266.53095416 305.91207233 310.97472232 277.71875 348.72265625 C263.60234344 367.18784377 247.15737468 381.4737136 228.29296875 394.8515625 C212.24430099 407.7654897 210.71676135 413.97621437 208.7734375 421.3828125 C181.53441262 506.54507196 178.70511668 504.40282009 175.6484375 502.0078125 C148.02520658 480.47123692 129.62033615 467.80137883 110.1484375 456.3828125 C-132.23462269 428.97121422 -175.13327954 411.03777396 -208.9140625 383.1328125 C-243.2511049 354.67901615 -266.24425682 319.45945446 -270.72216797 276.67504883 C-275.09278992 218.77264885 -258.16716682 157.0902502 -223.9140625 110.1328125 C-134.26093629 22.60307623 -64.74059361 -0.12860209 0 0 Z" transform="translate(522.9140625,309.8671875)"/>
                            
                            <!-- Inner circle/chat bubble -->
                            <path class="logo-primary" d="M0 0 C1.13418869 0.00090637 2.29129028 0.00183105 97.125 12.1875 C155.125 35.1875 176.9375 47.5 184.125 52.1875 C215.02803756 78.20054832 227.01255818 90.01678051 236.8984375 103.51660156 C275.12084722 173.1034806 278.49740088 185.10624011 281.47265625 197.48632812 C294.7478543 250.75457268 291.55737166 298.73898926 267.25390625 339.87890625 C233.86513617 379.13907117 222.75504275 387.30730784 211.30175781 395.24536133 C187.24609375 437.97265625 186.33071271 441.39098273 185.87232971 443.09996033 C156.3125 500.8125 154.96767828 499.71686632 152.2734375 497.53125 C129.06228543 478.90843176 106.41015668 462.84256456 82.3125 450.4375 C-127.24173162 437.23451231 -192.81069705 416.07006706 -240.875 370.1875 C-270.02687243 342.14774624 -287.12880274 305.34419483 -288.078125 268.38671875 C-288.81375602 208.01376003 -271.49544036 147.37583637 -232.875 100.1875 C-133.54611094 14.7765064 -65.14314952 -0.09769166 0 0 Z" transform="translate(540,240.6875)"/>
                            
                            <!-- Left eye -->
                            <path class="logo-eyes" d="M0 0 C10.19057989 6.17297395 13.46790559 15.95126261 16.37109375 26.9609375 C19.89235471 39.38186149 19.60427245 50.33379676 19.68359375 60.8359375 C19.84190759 75.29822571 18.49460912 86.58033118 11.37109375 94.9609375 C5.21330746 100.9787741 -0.58398384 103.09485392 -9.00390625 103.4609375 C-17.07841895 103.24574191 -23.40673358 100.66372893 -29.00390625 94.7734375 C-36.73325267 84.78878604 -36.86924894 73.42129142 -36.87890625 61.3984375 C-36.85380589 40.31376028 -36.42212501 18.47290959 -22.62890625 3.9609375 C-15.37910608 -2.76110709 -6.94576236 -2.74527903 0 0 Z" transform="translate(453.62890625,517.0390625)"/>
                            
                            <!-- Right eye -->
                            <path class="logo-eyes" d="M0 0 C10.33220651 5.85028967 14.19459567 16.75067806 17.37890625 27.6015625 C19.8365478 37.66705032 19.89396938 48.21041868 19.95532227 58.51269531 C20.26588753 73.90647886 19.35165866 86.10351739 11.66015625 95.15234375 C5.64992533 101.02597851 0.09420833 103.27026482 -8.21484375 103.58984375 C-16.1608803 103.33933818 -22.6013727 101.39400596 -28.21484375 95.58984375 C-40.06249592 80.66850824 -37.76127415 55.86897418 -36.0234375 37.87646484 C-34.14483587 24.77413042 -29.88769417 10.92912519 -19.82421875 1.7734375 C-14.15204834 -2.17780742 -6.37131597 -2.30813951 0 0 Z" transform="translate(644.33984375,516.84765625)"/>
                        </g>
                    </svg>
                    LexiAi
                </div>
                <div class="experiment-tag">Experiment</div>
            </div>
            <button class="theme-toggle" id="themeToggle">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </button>
        </header>
        
        <div class="main-content">
            <div id="homeView">
                <div class="greeting-section">
                    <h1>Hi, I'm LexiAi</h1>
                    <p>Tell me what's on your mind about underwriting. I have limitations and won't always get it right, but will do my best to answer your questions!</p>
                </div>
                
                <div class="suggestions-container">
                    <div class="suggestions-title">Getting Started</div>
                    <div class="suggestions-grid">
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Tell me about yourself</button>
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Where do you get your information from?</button>
                        <button class="suggestion-chip" onclick="submitSuggestion(this.textContent)">Who made this?</button>
                    </div>
                </div>
            </div>
            
            <div id="chatView" class="hidden">
                <div class="chat-container" id="chatMessages">
                    <!-- Messages will be added here dynamically -->
                </div>
            </div>
        </div>
        
        <div class="chat-input-area">
            <div class="chat-input-container">
                <textarea 
                    id="userMessage" 
                    class="chat-input" 
                    placeholder="Enter a prompt here" 
                    rows="1" 
                    onkeypress="handleKeyPress(event)"
                ></textarea>
                <button class="submit-button" onclick="sendMessage()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="currentColor"></path>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress"></div>
        </div>
        
        <div class="attribution">
            <div>Developed by <a href="https://www.linkedin.com/in/do-jennifer/" target="_blank">Jennifer Do</a></div>
        </div>
        
        <div class="disclaimer">
            LexiAi may display inaccurate or offensive information that doesn't represent our views.
        </div>
    </div>
    
    <script>
        // Helper function to escape special characters for regex
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
        }
        
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        // Set initial icon for dark mode
        themeToggle.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
        `;
        
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Update icon if needed
            if (newTheme === 'dark') {
                themeToggle.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                `;
            } else {
                themeToggle.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                `;
            }
        });
        
        // Handle submission of suggestion chips
        function submitSuggestion(text) {
            document.getElementById('userMessage').value = text;
            sendMessage();
        }
        
        // Function to check if user is asking who made the application
        function isAskingWhoMade(userInput) {
            const normalizedInput = userInput.toLowerCase().trim().replace(/[?!.,]/g, '');
            const whoMadePatterns = [
                'who made this',
                'who created this',
                'who developed this',
                'who built this',
                'who is the creator',
                'who is the developer',
                'about the creator',
                'about the developer'
            ];
            
            return whoMadePatterns.some(pattern => normalizedInput.includes(pattern));
        }
        
        // Hardcoded response about LexiAI
        const whoMadeResponse = `LexiAI, developed by <a href="https://www.linkedin.com/in/do-jennifer/" target="_blank">Jennifer Do</a>, is an AI-powered chatbot designed to assist with underwriting regulations in Ontario's auto insurance industry. Acting as an expert representative of the Financial Services Regulatory Authority of Ontario (FSRA), LexiAI answers complex underwriting queries from insurers, consumers, and FSRA employees, ensuring decisions align with regulatory standards.
        
        LexiAI was built to address two primary use cases:
        
        Underwriting Decline Rules – When an insurer wants to know if they can legally deny coverage based on a specific condition, LexiAI scans FSRA's regulatory documents and provides a compliance verdict, backed by citations.
        New Rule Submissions – Insurers propose new underwriting rules. LexiAI assesses whether the rule meets legal, ethical, and industry standards, considering fairness, objectivity, and precedent before delivering a decision.
        To power LexiAI, we developed a custom web scraper that collects legal and regulatory texts from Ontario's official databases. Using BeautifulSoup and Requests, this data is structured and fed into an LLM-powered framework, enabling LexiAI to process underwriting rules with accuracy and transparency.
        
        For each query, LexiAI provides:
        
        A compliance verdict (confidence score from 0-10)
        Justification based on FSRA guidelines
        Cited references to regulatory documents
        By automating compliance analysis, LexiAI streamlines regulatory decision-making for insurers and regulators alike.`;
        
        // Replace the current scrollChatToBottom function with this enhanced version
        function scrollChatToBottom() {
            const chatMessages = document.getElementById("chatMessages");
            
            // First immediate scroll to try to get to the bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Then use requestAnimationFrame for after the next paint
            requestAnimationFrame(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Add a backup delayed scroll to handle any late rendering
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 100);
            });
        }
        
        // Add this helper function at the top of your script section
        function handleApiError(error) {
            console.error("API Error:", error);
            
            // Check for specific error types
            if (error.message && error.message.includes("405")) {
                return "The server is currently unavailable. This could be due to maintenance or configuration issues. Please try again later.";
            } else if (error.message && error.message.includes("Network Error")) {
                return "Unable to connect to the server. Please check your internet connection and try again.";
            } else if (error.message && error.message.includes("timeout")) {
                return "The request timed out. The server might be experiencing high load. Please try again later.";
            } else {
                return `An error occurred: ${error.message}. Please try again later or contact support if the issue persists.`;
            }
        }
        
        // Add these helper functions at the top of your script section
        function getLocalResponse(userInput) {
            // Simple keyword-based response system
            userInput = userInput.toLowerCase();
            
            if (userInput.includes('hello') || userInput.includes('hi')) {
                return "Hello! I'm LexiAI, your assistant for underwriting regulations. How can I help you today?";
            }
            
            if (userInput.includes('tell me about yourself') || userInput.includes('what can you do')) {
                return "I'm LexiAI, an AI-powered assistant focused on Ontario's auto insurance regulations. I can help answer questions about underwriting rules, regulatory compliance, and FSRA guidelines. While my responses are informative, they should not be considered legal advice.";
            }
            
            if (userInput.includes('information') || userInput.includes('where do you get')) {
                return "My knowledge is based on Ontario's auto insurance regulations, including the Insurance Act, FSRA guidelines, and associated regulatory documents. This information has been processed to help me provide relevant responses about underwriting rules and compliance requirements.";
            }
            
            // Default response
            return "I understand you're asking about underwriting regulations. Due to temporary connectivity issues, I can only provide limited responses. Please try again later when the system is fully operational, or ask a different question I might be able to help with.";
        }
        
        async function fetchCitationMappings() {
            try {
                const response = await fetch("/public/citation_mappings.json");
                if (!response.ok) {
                    console.error("Failed to load citation mappings:", response.status);
                    return {};
                }
                const data = await response.json();
                
                // Convert the array to an object keyed by filename for easy lookup
                const mappings = {};
                data.mappings.forEach(item => {
                    mappings[item.filename] = {
                        display_name: item.display_name,
                        source_url: item.source_url
                    };
                });
                
                return mappings;
            } catch (error) {
                console.error("Error loading citation mappings:", error);
                return {};
            }
        }
        
        async function sendMessage() {
            const userMessage = document.getElementById("userMessage").value;
            const chatMessages = document.getElementById("chatMessages");
            
            if (!userMessage) {
                alert("Please enter a message.");
                return;
            }
            
            // Show chat view, hide home view
            document.getElementById('homeView').classList.add('hidden');
            document.getElementById('chatView').classList.remove('hidden');
            
            // Add user message to chat
            const userDiv = document.createElement("div");
            userDiv.className = "message user-message";
            userDiv.textContent = userMessage;
            chatMessages.appendChild(userDiv);
            
            // Clear input field and scroll to bottom
            document.getElementById("userMessage").value = "";
            scrollChatToBottom();
            
            // Create typing indicator
            const loadingDiv = document.createElement("div");
            loadingDiv.className = "message assistant-message typing-indicator";
            loadingDiv.innerHTML = "<span></span><span></span><span></span>";
            chatMessages.appendChild(loadingDiv);
            scrollChatToBottom();

            try {
                // Check for "Who made this?" first
                if (isAskingWhoMade(userMessage)) {
                    // Simulate a delayed response with the loading animation
                    setTimeout(() => {
                        // Remove loading indicator
                        chatMessages.removeChild(loadingDiv);
                        
                        // Display hardcoded response
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        assistantDiv.innerHTML = whoMadeResponse;
                        chatMessages.appendChild(assistantDiv);
                        scrollChatToBottom();
                    }, 2000); // Reduced to 2 second delay
                    
                    // Return early to prevent API calls
                    return;
                }
                
                // Wrap API calls in a try-catch to handle any errors
                try {
                    // Step 1: Create a Thread
                    const threadResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ action: "createThread" })
                    });
                    
                    // Check if response is ok before parsing JSON
                    if (!threadResponse.ok) {
                        throw new Error(`Server error: ${threadResponse.status} ${threadResponse.statusText}`);
                    }
                    
                    let threadData;
                    try {
                        threadData = await threadResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse thread response: " + e.message);
                    }
                    
                    if (!threadData.threadId) throw new Error("Error creating thread: Missing threadId");
                    const threadId = threadData.threadId;
                    
                    // Step 2: Add Message to Thread
                    const messageResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "addMessage", 
                            threadId: threadId, 
                            userMessage: userMessage 
                        })
                    });
                    
                    if (!messageResponse.ok) {
                        throw new Error(`Server error: ${messageResponse.status} ${messageResponse.statusText}`);
                    }
                    
                    let messageData;
                    try {
                        messageData = await messageResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse message response: " + e.message);
                    }
                    
                    if (messageData.error) throw new Error(messageData.error);
                    
                    // Step 3: Run the Assistant
                    const runResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "runAssistant", 
                            threadId: threadId
                        })
                    });
                    
                    if (!runResponse.ok) {
                        throw new Error(`Server error: ${runResponse.status} ${runResponse.statusText}`);
                    }
                    
                    let runData;
                    try {
                        runData = await runResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse run response: " + e.message);
                    }
                    
                    if (!runData.runId) throw new Error("Error running assistant: Missing runId");
                    const runId = runData.runId;
                    
                    // Step 4: Poll for Completion
                    let status = "in_progress";
                    let checkRunData;
                    
                    while (status === "in_progress" || status === "queued") {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        const checkRunResponse = await fetch("/.netlify/functions/openai-proxy", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ 
                                action: "checkRun", 
                                threadId: threadId,
                                runId: runId
                            })
                        });
                        
                        if (!checkRunResponse.ok) {
                            throw new Error(`Server error: ${checkRunResponse.status} ${checkRunResponse.statusText}`);
                        }
                        
                        try {
                            checkRunData = await checkRunResponse.json();
                            status = checkRunData.status;
                        } catch (e) {
                            throw new Error("Failed to parse check run response: " + e.message);
                        }
                    }
                    
                    // Step 5: Retrieve Response
                    const messagesResponse = await fetch("/.netlify/functions/openai-proxy", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                            action: "getMessages", 
                            threadId: threadId
                        })
                    });
                    
                    if (!messagesResponse.ok) {
                        throw new Error(`Server error: ${messagesResponse.status} ${messagesResponse.statusText}`);
                    }
                    
                    let messagesData;
                    try {
                        messagesData = await messagesResponse.json();
                    } catch (e) {
                        throw new Error("Failed to parse messages response: " + e.message);
                    }
                    
                    // Remove loading indicator
                    if (loadingDiv.parentNode) {
                        chatMessages.removeChild(loadingDiv);
                    }
                    
                    // Process and display assistant response
                    const assistantMessage = messagesData.messages && messagesData.messages.find(msg => msg.role === "assistant");
                    if (assistantMessage && assistantMessage.content) {
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        
                        // Process the message content based on its type
                        let formattedContent = "";
                        let citations = [];
                        
                        // Process all content items from the message
                        for (const content of assistantMessage.content) {
                            if (content.type === "text") {
                                // Get the text content and annotations
                                let text = content.text.value;
                                const annotations = content.text.annotations || [];
                                
                                // Process annotations (citations) if present
                                if (annotations && annotations.length > 0) {
                                    let citationIndex = 0;
                                    
                                    // Create an array to track positions where text needs to be replaced
                                    // This avoids issues with multiple replacements changing string offsets
                                    const replacements = [];
                                    
                                    // Process each annotation
                                    for (const annotation of annotations) {
                                        // Get the citation text and its position
                                        const citationText = annotation.text;
                                        
                                        // If it's a file citation
                                        if (annotation.file_citation) {
                                            const fileId = annotation.file_citation.file_id;
                                            // Use 1-based indexing for display
                                            const displayIndex = citationIndex + 1;
                                            const citationMarker = `[${displayIndex}]`;
                                            
                                            // Add to replacements array
                                            replacements.push({
                                                text: citationText,
                                                replacement: citationMarker
                                            });
                                            
                                            // Add to citations array
                                            citations.push({
                                                index: citationIndex,
                                                displayIndex: displayIndex,
                                                fileId: fileId
                                            });
                                            
                                            citationIndex++;
                                        }
                                    }
                                    
                                    // Apply all replacements
                                    // Replace all instances of citation text with the citation markers
                                    replacements.forEach(({ text: citationText, replacement }) => {
                                        // Use a regex to globally replace all instances of the citation text
                                        const regex = new RegExp(escapeRegExp(citationText), 'g');
                                        text = text.replace(regex, replacement);
                                    });
                                }
                                
                                // Format code blocks
                                text = text.replace(/```(\w*)([\s\S]*?)```/g, function(match, language, code) {
                                    return `<div class="pre-formatted">${code.trim()}</div>`;
                                });
                                
                                // Format markdown headings (### Heading) with special classes for verdict and reasoning
                                text = text.replace(/^###\s+(.*?)$/gm, function(match, heading) {
                                    if (heading.toLowerCase().includes('verdict')) {
                                        return `<h3 class="verdict-heading">${heading}</h3>`;
                                    } else if (heading.toLowerCase().includes('reasoning')) {
                                        return `<h3 class="reasoning-heading">${heading}</h3>`;
                                    } else {
                                        return `<h3>${heading}</h3>`;
                                    }
                                });
                                
                                // Format numbered reasons with special styling (e.g., "1. **Subjectivity and Arbitrary Nature**:")
                                text = text.replace(/(\d+)\.\s+\*\*(.*?)\*\*\s*:\s*(.*?)(?=(\n\d+\.\s+\*\*|\n### |\n$|$))/gs, 
                                    function(match, number, title, content) {
                                        return `<div class="reasoning-point">
                                            <span class="reasoning-point-number">${number}.</span>
                                            <strong>${title}</strong>: ${content.trim()}
                                        </div>`;
                                    });
                                
                                // Format confidence interval patterns like "**Confidence Interval: 9/10**"
                                text = text.replace(/\*\*Confidence Interval:?\s*([\d\.\/]+)\*\*/gi, 
                                    '<div class="confidence-interval">Confidence Interval: $1</div>');
                                
                                // Format verdict patterns
                                text = text.replace(/\*\*Not Compliant\*\*/gi, 
                                    '<strong style="color: var(--primary-color);">Not Compliant</strong>');
                                
                                // Format bold text (**text**)
                                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                                
                                // Handle consecutive numbered list items more effectively
                                let inNumberedList = false;
                                const lines = text.split('\n');
                                const processedLines = [];
                                
                                for (let i = 0; i < lines.length; i++) {
                                    const line = lines[i];
                                    const numberedListMatch = line.match(/^(\d+)\.\s+(.*?)$/);
                                    
                                    if (numberedListMatch) {
                                        if (!inNumberedList) {
                                            // Start a new list
                                            inNumberedList = true;
                                            processedLines.push(`<ol start="${numberedListMatch[1]}">`);
                                        }
                                        // Add list item
                                        processedLines.push(`<li>${numberedListMatch[2]}</li>`);
                                    } else {
                                        if (inNumberedList) {
                                            // Close the list
                                            inNumberedList = false;
                                            processedLines.push('</ol>');
                                        }
                                        processedLines.push(line);
                                    }
                                }
                                
                                // Close any open list
                                if (inNumberedList) {
                                    processedLines.push('</ol>');
                                }
                                
                                text = processedLines.join('\n');
                                
                                // Handle bullet lists in a similar way
                                inNumberedList = false;
                                const bulletLines = text.split('\n');
                                const processedBulletLines = [];
                                
                                for (let i = 0; i < bulletLines.length; i++) {
                                    const line = bulletLines[i];
                                    const bulletListMatch = line.match(/^\*\s+(.*?)$/);
                                    
                                    if (bulletListMatch) {
                                        if (!inNumberedList) {
                                            // Start a new list
                                            inNumberedList = true;
                                            processedBulletLines.push('<ul>');
                                        }
                                        // Add list item
                                        processedBulletLines.push(`<li>${bulletListMatch[1]}</li>`);
                                    } else {
                                        if (inNumberedList) {
                                            // Close the list
                                            inNumberedList = false;
                                            processedBulletLines.push('</ul>');
                                        }
                                        processedBulletLines.push(line);
                                    }
                                }
                                
                                // Close any open list
                                if (inNumberedList) {
                                    processedBulletLines.push('</ul>');
                                }
                                
                                text = processedBulletLines.join('\n');
                                
                                // Convert line breaks (but not inside HTML elements)
                                text = text.replace(/(?<!\>)\n(?!\<)/g, "<br>");
                                
                                formattedContent += text;
                            }
                        }
                        
                        // Add the formatted content to the message
                        assistantDiv.innerHTML = formattedContent;
                        
                        // If we have citations, fetch and display them
                        if (citations.length > 0) {
                            const citationsDiv = document.createElement("div");
                            citationsDiv.className = "message-citations";
                            citationsDiv.innerHTML = "<hr><h4>Sources:</h4><ol class='citation-list'></ol>";
                            const citationsList = citationsDiv.querySelector('.citation-list');
                            
                            // Process each citation asynchronously
                            const processCitations = async () => {
                                // First fetch the citation mappings
                                const citationMappings = await fetchCitationMappings();
                                
                                // Create an array to hold all citation items until we're ready to add them
                                const citationItems = new Array(citations.length);
                                
                                // Process all citations
                                const processPromises = citations.map(async (citation) => {
                                    try {
                                        // Fetch file information
                                        const fileResponse = await fetch("/.netlify/functions/openai-proxy", {
                                            method: "POST",
                                            headers: { "Content-Type": "application/json" },
                                            body: JSON.stringify({ 
                                                action: "retrieveFile", 
                                                fileId: citation.fileId
                                            })
                                        });
                                        
                                        const fileData = await fileResponse.json();
                                        const filename = fileData.file.filename;
                                        
                                        // Create citation item
                                        const citationItem = document.createElement("li");
                                        citationItem.value = citation.displayIndex || (citation.index + 1); // Ensure 1-based numbering
                                        
                                        // Normalize the filename for more robust matching
                                        // 1. Get basename without extension (if any)
                                        const basename = filename.split('.')[0] || filename;
                                        
                                        // 2. Try multiple matching strategies
                                        let found = false;
                                        let mapping = null;
                                        
                                        // First try exact match
                                        if (citationMappings[filename]) {
                                            mapping = citationMappings[filename];
                                            found = true;
                                        } 
                                        // Then try basename match
                                        else if (citationMappings[basename]) {
                                            mapping = citationMappings[basename];
                                            found = true;
                                        } 
                                        // If still not found, try finding by partial match
                                        else {
                                            for (const key in citationMappings) {
                                                // Check if key starts with or contains the basename
                                                if (key.includes(basename) || basename.includes(key)) {
                                                    mapping = citationMappings[key];
                                                    found = true;
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        // Display citation with proper formatting
                                        if (found && mapping) {
                                            citationItem.innerHTML = `<a href="${mapping.source_url}" target="_blank">${mapping.display_name}</a>`;
                                        } else {
                                            // If no mapping is found, just show the filename
                                            console.warn(`No mapping found for filename: ${filename}`);
                                            citationItem.textContent = filename;
                                        }
                                        
                                        // Store the item in the correct position in our array
                                        citationItems[citation.index] = citationItem;
                                    } catch (error) {
                                        console.error("Error fetching citation:", error);
                                        const citationItem = document.createElement("li");
                                        // Use 1-based indexing for the display
                                        citationItem.value = citation.displayIndex || (citation.index + 1);
                                        citationItem.textContent = `Citation ${citation.displayIndex || (citation.index + 1)} (Unable to retrieve details)`;
                                        
                                        // Store the error item in the correct position
                                        citationItems[citation.index] = citationItem;
                                    }
                                });
                                
                                // Wait for all citations to be processed
                                await Promise.all(processPromises);
                                
                                // Now add all citation items to the list in the correct order
                                citationItems.forEach(item => {
                                    if (item) {
                                        citationsList.appendChild(item);
                                    }
                                });
                            };
                            
                            // Start processing citations
                            processCitations();
                            
                            // Add citations div to the message
                            assistantDiv.appendChild(citationsDiv);
                        }
                        
                        chatMessages.appendChild(assistantDiv);
                    } else {
                        const errorDiv = document.createElement("div");
                        errorDiv.className = "message assistant-message";
                        errorDiv.textContent = "No response from assistant. The API may be temporarily unavailable.";
                        chatMessages.appendChild(errorDiv);
                    }
                } catch (apiError) {
                    console.error("API Error:", apiError);
                    
                    // Server is unavailable, use the fallback system
                    setTimeout(() => {
                        // Remove loading indicator
                        chatMessages.removeChild(loadingDiv);
                        
                        // Show fallback response
                        const assistantDiv = document.createElement("div");
                        assistantDiv.className = "message assistant-message";
                        assistantDiv.innerHTML = getLocalResponse(userMessage);
                        chatMessages.appendChild(assistantDiv);
                        
                        // Add a note about offline mode
                        const noteDiv = document.createElement("div");
                        noteDiv.className = "message assistant-message";
                        noteDiv.innerHTML = "<em>Note: LexiAI is currently in offline mode due to server connectivity issues.</em>";
                        noteDiv.style.fontSize = "0.8em";
                        noteDiv.style.opacity = "0.7";
                        chatMessages.appendChild(noteDiv);
                        
                        scrollChatToBottom();
                    }, 1500);
                    
                    return;
                }
            } catch (error) {
                console.error("Error:", error);
                
                // Remove loading indicator if it exists
                if (loadingDiv.parentNode) {
                    chatMessages.removeChild(loadingDiv);
                }
                
                // Get user-friendly error message
                const errorMessage = handleApiError(error);
                
                // Show error message
                const errorDiv = document.createElement("div");
                errorDiv.className = "message assistant-message";
                errorDiv.textContent = errorMessage;
                chatMessages.appendChild(errorDiv);
                
                scrollChatToBottom();
            }
            
            // Scroll to bottom
            scrollChatToBottom();
        }
        
        // Allow pressing Enter key to send message
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // Auto-resize textarea
        const textarea = document.getElementById('userMessage');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
        
        // Function to reset to home page
        function resetToHome() {
            // Show home view, hide chat view
            document.getElementById('homeView').classList.remove('hidden');
            document.getElementById('chatView').classList.add('hidden');
            
            // Clear the chat messages
            document.getElementById('chatMessages').innerHTML = '';
            
            // Clear the input field if there's any text
            document.getElementById('userMessage').value = '';
        }
    </script>
</body>
</html> 